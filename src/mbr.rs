#![allow(missing_docs)]

use crate::{Block, BlockCount, BlockDevice, BlockIdx};
use core::{convert::TryInto, fmt::Debug};

#[derive(Debug)]
pub enum Error<BlockDeviceError>
where
    BlockDeviceError: Debug,
{
    DeviceError(BlockDeviceError),
    InvalidMbrSignature,
    InvalidPartitionStatus,
    UnsupportedPartitionType(u8),
    InfoTooShort,
}

impl<BDE> From<BDE> for Error<BDE>
where
    BDE: Debug,
{
    fn from(e: BDE) -> Self {
        Self::DeviceError(e)
    }
}

#[derive(Debug, PartialEq)]
pub enum VolumeType {
    Fat,
}

pub enum PartitionNumber {
    One,
    Two,
    Three,
    Four,
}

impl PartitionNumber {
    pub fn from_number(number: usize) -> Option<Self> {
        let partition = match number {
            1 => Self::One,
            2 => Self::One,
            3 => Self::Two,
            4 => Self::Three,
            _ => return None,
        };
        Some(partition)
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum PartitionType {
    Fat32ChsLba,
    Fat32Lba,
    Fat16Lba,
    Fat16,
    Unknown(u8),
}

impl PartitionType {
    /// Marker for a FAT32 partition. What Macosx disk utility (and also SD-Card formatter?)
    /// use.
    const FAT32_CHS_LBA: u8 = 0x0B;
    /// Marker for a FAT32 partition. Sometimes also use for FAT16 formatted
    /// partitions.
    const FAT32_LBA: u8 = 0x0C;
    /// Marker for a FAT16 partition with LBA. Seen on a Raspberry Pi SD card.
    const FAT16_LBA: u8 = 0x0E;
    /// Marker for a FAT16 partition. Seen on a card formatted with the official
    /// SD-Card formatter.
    const FAT16: u8 = 0x06;

    pub fn from_u8(value: u8) -> Self {
        match value {
            Self::FAT32_CHS_LBA => Self::Fat32ChsLba,
            Self::FAT32_LBA => Self::Fat32Lba,
            Self::FAT16_LBA => Self::Fat16Lba,
            Self::FAT16 => Self::Fat16,
            _ => Self::Unknown(value),
        }
    }
}

#[derive(Debug)]
pub enum PartitionError<E>
where
    E: Debug,
{
    DeviceError(E),
    OutOfRange { partition_block_count: BlockCount },
}

pub struct Partition<BD>
where
    BD: BlockDevice,
{
    block_device: BD,
    info: PartitionInfo,
}

impl<BD> Partition<BD>
where
    BD: BlockDevice,
{
    pub fn info(&self) -> &PartitionInfo {
        &self.info
    }

    fn range_check<E>(&self, start: u32, len: u32) -> Result<(), PartitionError<E>>
    where
        E: Debug,
    {
        let last_block = start + len;

        if last_block > self.info.block_count.0 {
            return Err(PartitionError::OutOfRange {
                partition_block_count: self.info.block_count,
            });
        } else {
            Ok(())
        }
    }
}

impl<BD> BlockDevice for Partition<BD>
where
    BD: BlockDevice,
{
    type Error = PartitionError<BD::Error>;

    fn read(
        &mut self,
        blocks: &mut [Block],
        start_block_idx: BlockIdx,
        reason: &str,
    ) -> Result<(), Self::Error> {
        let blocks_to_read = blocks.len() as u32;
        self.range_check(start_block_idx.0, blocks_to_read)?;

        let part_start_block_idx = start_block_idx + self.info.lba_start;

        self.block_device
            .read(blocks, part_start_block_idx, reason)
            .map_err(|e| PartitionError::DeviceError(e))
    }

    fn write(&mut self, blocks: &[Block], start_block_idx: BlockIdx) -> Result<(), Self::Error> {
        let blocks_to_write = blocks.len() as u32;
        self.range_check(start_block_idx.0, blocks_to_write)?;

        let part_start_block_idx = start_block_idx + self.info.lba_start;

        self.block_device
            .write(blocks, part_start_block_idx)
            .map_err(|e| PartitionError::DeviceError(e))
    }

    fn num_blocks(&mut self) -> Result<BlockCount, Self::Error> {
        Ok(self.info.block_count)
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct PartitionInfo {
    pub ty: PartitionType,
    pub lba_start: BlockCount,
    pub block_count: BlockCount,
}

impl PartitionInfo {
    const STATUS_IDX: usize = 0;
    const TYPE_IDX: usize = 4;
    const LBA_START_IDX: usize = 8;
    const NUM_BLOCKS_IDX: usize = 12;
    pub(crate) const PARTITION_INFO_LENGTH: usize = 16;

    pub fn from_info_bytes<E>(info: &[u8]) -> Result<Self, Error<E>>
    where
        E: Debug,
    {
        if info.len() != Self::PARTITION_INFO_LENGTH {
            return Err(Error::InfoTooShort);
        }

        let pstatus = info[Self::STATUS_IDX];
        if pstatus != 0x80 && pstatus != 0x00 {
            return Err(Error::InvalidPartitionStatus);
        }

        let lba_start = u32::from_le_bytes(
            info[Self::LBA_START_IDX..Self::LBA_START_IDX + 4]
                .try_into()
                .expect("Infallible"),
        );

        let num_blocks = u32::from_le_bytes(
            info[Self::NUM_BLOCKS_IDX..Self::NUM_BLOCKS_IDX + 4]
                .try_into()
                .expect("Infallible"),
        );

        let partition_type = PartitionType::from_u8(info[Self::TYPE_IDX]);

        Ok(PartitionInfo {
            ty: partition_type,
            lba_start: BlockCount(lba_start),
            block_count: BlockCount(num_blocks),
        })
    }
}

pub enum PartitionOpenMode {
    ReadWrite,
    ReadOnly,
}

pub struct Mbr<BD> {
    block_dev: BD,
    partitions: [Option<PartitionInfo>; 4],
}

impl<BD> Debug for Mbr<BD>
where
    BD: Debug,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("Mbr")
            .field("partitions", &self.partitions)
            .finish()
    }
}

impl<BD> Mbr<BD> {
    pub fn get_partition_info(&self, partition_num: PartitionNumber) -> Option<PartitionInfo> {
        let index = match partition_num {
            PartitionNumber::One => 0,
            PartitionNumber::Two => 1,
            PartitionNumber::Three => 2,
            PartitionNumber::Four => 3,
        };
        self.partitions[index]
    }

    pub fn release(self) -> BD {
        self.block_dev
    }

    pub fn with_device<BDN>(self, new_block_dev: BDN) -> (Mbr<BDN>, BD) {
        (
            Mbr {
                block_dev: new_block_dev,
                partitions: self.partitions,
            },
            self.block_dev,
        )
    }
}

impl<BD> Mbr<BD>
where
    BD: BlockDevice,
{
    const FOOTER_START: usize = 510;
    const FOOTER_VALUE: u16 = 0xAA55;
    const PARTITION1_START: usize = 446;
    const PARTITION2_START: usize = Self::PARTITION1_START + PartitionInfo::PARTITION_INFO_LENGTH;
    const PARTITION3_START: usize = Self::PARTITION2_START + PartitionInfo::PARTITION_INFO_LENGTH;
    const PARTITION4_START: usize = Self::PARTITION3_START + PartitionInfo::PARTITION_INFO_LENGTH;

    pub fn new(mut block_dev: BD) -> Result<Self, Error<BD::Error>> {
        let mut blocks = [Block::new()];
        block_dev.read(&mut blocks, BlockIdx(0), "read_mbr")?;
        let [first_block] = blocks;

        let footer = u16::from_le_bytes(
            first_block[Self::FOOTER_START..Self::FOOTER_START + 2]
                .try_into()
                .expect("Infallible"),
        );

        if footer != Self::FOOTER_VALUE {
            return Err(Error::InvalidMbrSignature);
        }

        let partitions = [
            Self::read_partition_info(&first_block, PartitionNumber::One).ok(),
            Self::read_partition_info(&first_block, PartitionNumber::Two).ok(),
            Self::read_partition_info(&first_block, PartitionNumber::Three).ok(),
            Self::read_partition_info(&first_block, PartitionNumber::Four).ok(),
        ];

        Ok(Self {
            block_dev,
            partitions,
        })
    }

    fn read_partition_info(
        first_block: &Block,
        partition_num: PartitionNumber,
    ) -> Result<PartitionInfo, Error<BD::Error>> {
        let pinfo_start = match partition_num {
            PartitionNumber::One => Self::PARTITION1_START,
            PartitionNumber::Two => Self::PARTITION2_START,
            PartitionNumber::Three => Self::PARTITION3_START,
            PartitionNumber::Four => Self::PARTITION4_START,
        };

        let pinfo_data =
            &first_block[pinfo_start..pinfo_start + PartitionInfo::PARTITION_INFO_LENGTH];
        PartitionInfo::from_info_bytes(pinfo_data)
    }
}

impl<'bd, BD> Mbr<BD>
where
    &'bd mut BD: BlockDevice + 'bd,
{
    pub fn open_partition(
        &'bd mut self,
        partition_num: PartitionNumber,
    ) -> Option<Partition<&'bd mut BD>> {
        let partition_info = self.get_partition_info(partition_num)?;
        Some(Partition {
            block_device: &mut self.block_dev,
            info: partition_info,
        })
    }
}

impl<'bd, BD> Mbr<BD>
where
    &'bd BD: BlockDevice + 'bd,
{
    /// Get representation for the partition with number `partition_num`, passing
    /// this partition an immutable reference to the `BD` stored within this `Mbr`,
    /// so that multiple partitions can be opened simultaneously
    pub fn get_partition_immut(
        &'bd self,
        partition_num: PartitionNumber,
    ) -> Option<Partition<&'bd BD>> {
        let partition_info = self.get_partition_info(partition_num)?;
        Some(Partition {
            block_device: &self.block_dev,
            info: partition_info,
        })
    }
}

impl<BD> Clone for Mbr<BD>
where
    BD: Clone,
{
    fn clone(&self) -> Self {
        Self {
            block_dev: self.block_dev.clone(),
            partitions: self.partitions.clone(),
        }
    }
}

impl<BD> Mbr<BD>
where
    BD: Clone,
{
    /// Replace the underlying device for this `Mbr` with `new_block_dev`, and return a
    /// clone of the previously owned `BD`,
    pub fn with_device_cloned<BDN>(&mut self, new_block_dev: BDN) -> (Mbr<BDN>, BD) {
        (
            Mbr {
                partitions: self.partitions,
                block_dev: new_block_dev,
            },
            self.block_dev.clone(),
        )
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[derive(Debug)]
    enum Error {
        Unknown,
    }

    const BLOCKS: [Block; 3] = [
        // Actual blocks taken from an SD card, except with changed start and length of partition 0.
        Block {
            contents: [
                0xfa, 0xb8, 0x00, 0x10, 0x8e, 0xd0, 0xbc, 0x00, 0xb0, 0xb8, 0x00, 0x00, 0x8e, 0xd8,
                0x8e, 0xc0, // 0x000
                0xfb, 0xbe, 0x00, 0x7c, 0xbf, 0x00, 0x06, 0xb9, 0x00, 0x02, 0xf3, 0xa4, 0xea, 0x21,
                0x06, 0x00, // 0x010
                0x00, 0xbe, 0xbe, 0x07, 0x38, 0x04, 0x75, 0x0b, 0x83, 0xc6, 0x10, 0x81, 0xfe, 0xfe,
                0x07, 0x75, // 0x020
                0xf3, 0xeb, 0x16, 0xb4, 0x02, 0xb0, 0x01, 0xbb, 0x00, 0x7c, 0xb2, 0x80, 0x8a, 0x74,
                0x01, 0x8b, // 0x030
                0x4c, 0x02, 0xcd, 0x13, 0xea, 0x00, 0x7c, 0x00, 0x00, 0xeb, 0xfe, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x040
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x050
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x060
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x070
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x080
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x090
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x0A0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x0B0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x0C0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x0D0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x0E0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x0F0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x100
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x110
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x120
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x130
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x140
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x150
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x160
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x170
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x180
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x190
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x1A0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xca, 0xde, 0x06, 0x00, 0x00,
                0x00, 0x04, // 0x1B0
                0x01, 0x04, 0x0c, 0xfe, 0xc2, 0xff, 0x01, 0x00, 0x00, 0x00, 0x33, 0x22, 0x11, 0x00,
                0x00, 0x00, // 0x1C0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x1D0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x1E0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x55, 0xaa, // 0x1F0
            ],
        },
        Block {
            contents: [
                0xeb, 0x58, 0x90, 0x6d, 0x6b, 0x66, 0x73, 0x2e, 0x66, 0x61, 0x74, 0x00, 0x02, 0x08,
                0x20, 0x00, // 0x000
                0x02, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x08,
                0x00, 0x00, // 0x010
                0x00, 0x20, 0x76, 0x00, 0x80, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
                0x00, 0x00, // 0x020
                0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x030
                0x80, 0x01, 0x29, 0x0b, 0xa8, 0x89, 0x27, 0x50, 0x69, 0x63, 0x74, 0x75, 0x72, 0x65,
                0x73, 0x20, // 0x040
                0x20, 0x20, 0x46, 0x41, 0x54, 0x33, 0x32, 0x20, 0x20, 0x20, 0x0e, 0x1f, 0xbe, 0x77,
                0x7c, 0xac, // 0x050
                0x22, 0xc0, 0x74, 0x0b, 0x56, 0xb4, 0x0e, 0xbb, 0x07, 0x00, 0xcd, 0x10, 0x5e, 0xeb,
                0xf0, 0x32, // 0x060
                0xe4, 0xcd, 0x16, 0xcd, 0x19, 0xeb, 0xfe, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73,
                0x20, 0x6e, // 0x070
                0x6f, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20,
                0x64, 0x69, // 0x080
                0x73, 0x6b, 0x2e, 0x20, 0x20, 0x50, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x69, 0x6e,
                0x73, 0x65, // 0x090
                0x72, 0x74, 0x20, 0x61, 0x20, 0x62, 0x6f, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20,
                0x66, 0x6c, // 0x0A0
                0x6f, 0x70, 0x70, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x0d, 0x0a, 0x70, 0x72, 0x65, 0x73,
                0x73, 0x20, // 0x0B0
                0x61, 0x6e, 0x79, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x72, 0x79,
                0x20, 0x61, // 0x0C0
                0x67, 0x61, 0x69, 0x6e, 0x20, 0x2e, 0x2e, 0x2e, 0x20, 0x0d, 0x0a, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x0D0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x0E0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x0F0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x100
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x110
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x120
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x130
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x140
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x150
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x160
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x170
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x180
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x190
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x1A0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x1B0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x1C0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x1D0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, // 0x1E0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x55, 0xaa, // 0x1F0
            ],
        },
        Block {
            contents: [
                0x52, 0x52, 0x61, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x72, 0x41, 0x61, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA,
            ],
        },
    ];

    struct DummyBlockDevice;

    impl BlockDevice for DummyBlockDevice {
        type Error = Error;

        /// Read one or more blocks, starting at the given block index.
        fn read(
            &mut self,
            blocks: &mut [Block],
            start_block_idx: BlockIdx,
            _reason: &str,
        ) -> Result<(), Self::Error> {
            println!(
                "Reading block {} to {}",
                start_block_idx.0,
                start_block_idx.0 as usize + blocks.len()
            );
            for (idx, block) in blocks.iter_mut().enumerate() {
                let block_idx = start_block_idx.0 as usize + idx;
                if block_idx < BLOCKS.len() {
                    *block = BLOCKS[block_idx].clone();
                } else {
                    return Err(Error::Unknown);
                }
            }
            Ok(())
        }

        /// Write one or more blocks, starting at the given block index.
        fn write(
            &mut self,
            _blocks: &[Block],
            _start_block_idx: BlockIdx,
        ) -> Result<(), Self::Error> {
            unimplemented!();
        }

        /// Determine how many blocks this device can hold.
        fn num_blocks(&mut self) -> Result<BlockCount, Self::Error> {
            Ok(BlockCount(2))
        }
    }

    #[test]
    fn partition_one() {
        let mut mbr = Mbr::new(DummyBlockDevice).unwrap();
        let mut partition_one = mbr.open_partition(PartitionNumber::One).unwrap();

        assert_eq!(
            partition_one.info(),
            &PartitionInfo {
                ty: PartitionType::Fat32Lba,
                lba_start: BlockCount(1),
                block_count: BlockCount(0x0011_2233),
            }
        );

        let mut blocks = [Block::new()];

        // Verify that we can't read data beyond the end of the partition
        assert!(partition_one
            .read(&mut blocks, BlockIdx(3), "test_overread")
            .is_err());

        partition_one
            .read(&mut blocks, BlockIdx(0), "test")
            .unwrap();

        let [first_block] = blocks;
        assert_eq!(first_block.contents, BLOCKS[1].contents);
    }
}
